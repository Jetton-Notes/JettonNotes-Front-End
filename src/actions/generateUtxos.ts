import { bip32derivedDeposit, parseNote, toNoteHex } from "../crypto/cryptonotes";
import { decryptData, encryptData, Status } from "../crypto/encrypt";
import { getAccountKey, getAllUTXOs } from "../storage";

//TODO: this could have the how much... SO I have a function separate to generate
//TODO: and one separate to parse them
//TODO: There should be generate business logic,
//TODO: on wallet import it should iterate over the utxos and find all the deposits to show...
//TODO: always use a single utxo address fpr the wallet...
//Then on transfer out it migrates to a new address

export async function generateUTXOs(password: string, account_id: string) {
    const accountKeyFound = await getAccountKey();
    if (accountKeyFound) {
        const masterKeyData = await decryptData(accountKeyFound.cipherText.buffer, password);
        if (masterKeyData.status === Status.Success) {
            const parsedNote = await parseNote(masterKeyData.data);

            const res = await getAllUTXOs(account_id);

            //TODO: I need logic to generate more UTXOs or not, how much etc...

            //TODO: this will generate 20 notes...
            const generatedEncryptedNotes = await generateNotes(
                parsedNote.deposit.secret,
                parsedNote.deposit.nullifier,
                0,
                19,
                password,
                account_id
            );

            console.log(generatedEncryptedNotes);

            for (let i = 0; i < generatedEncryptedNotes.length; i++) {
                console.log(parseKeys(generatedEncryptedNotes[i].key));
            }
        }
    }
}

async function generateNotes(
    masterSecret: bigint,
    masterNullifier: bigint,
    startCounter: number,
    endCounter: number,
    password: string,
    account_id: string
) {
    let derivedNotes = []
    for (let i = startCounter; i < endCounter; i++) {
        const derived = await bip32derivedDeposit(
            {
                masterSecret,
                masterNullifier,
                counter: i
            })

        const commitment = toNoteHex(derived.commitment);
        const noteString = toNoteHex(derived.preimage, 64);
        const cipherTextOptions = await encryptData(noteString, password);

        derivedNotes.push({
            key: generateKey(account_id, i, commitment),
            value: cipherTextOptions.data
        });
    }
    return derivedNotes;
}



//Keys for the UTXOs are generated by combining the account_id and the index. 
// There are special character separators For the names

function generateKey(account_id: string, index: number, commitmentHash: string) {
    return `${account_id}&&${index}**${commitmentHash}`;
}

//This separates the keys at the special characters
function parseKeys(key: string): { account_id: string, index: string, commitmentHash: string } {
    const firstSplit = key.split("&&");
    const secondSplit = firstSplit[1].split("**");

    return {
        account_id: firstSplit[0],
        index: secondSplit[0],
        commitmentHash: secondSplit[1]
    }
}
